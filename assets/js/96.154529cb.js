(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{521:function(n,t,e){"use strict";e.r(t);var a=e(43),i=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"背景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[n._v("#")]),n._v(" 背景")]),n._v(" "),e("p",[n._v("我们要制作的是一个可以作为背景的特效，那么首要的条件就是这是一个背景，我们这里所说的背景是一个全屏的背景，充满你整个屏幕，我们来分析下 “全屏” 背景应该是怎样的。")]),n._v(" "),e("p",[n._v("在普通的页面制作中，我们观察设计稿，可以看出，背景往往是纯色的或者是渐变的，再或者就是有规律的可以平铺的图形。")]),n._v(" "),e("p",[e("strong",[n._v("为什么要将背景设置为纯色、渐变或可平铺的图形呢？")])]),n._v(" "),e("p",[n._v("为了适配所有的设备，尽可能让所有的设备都能够显示出相同的效果，不能相差太远，这种情况我们就只能将背景设置为单一的颜色，或者两种颜色（渐变），再或者一些可平铺的图案，让其在各个终端下都有相同的显示效果。")]),n._v(" "),e("p",[n._v("说到渐变，我个人是比较喜欢将背景设置为渐变的，关注我的朋友可能都知道，我文章的封面图一般都是一个渐变的背景 + 文字。简洁却不简单，因为每一个渐变图案都是我自己精挑细选的。\n"),e("a",{attrs:{href:"https://uigradients.com/#MangoPulp",target:"_blank",rel:"noopener noreferrer"}},[n._v("uigradients"),e("OutboundLink")],1),n._v("。")]),n._v(" "),e("h2",{attrs:{id:"炫酷"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#炫酷"}},[n._v("#")]),n._v(" 炫酷")]),n._v(" "),e("p",[n._v("怎么能让页面上的元素动起来呢？我们有以下几种方式：")]),n._v(" "),e("ul",[e("li",[n._v("gif 图")]),n._v(" "),e("li",[n._v("CSS3 动画")]),n._v(" "),e("li",[n._v("js 控制")]),n._v(" "),e("li",[n._v("svg")]),n._v(" "),e("li",[n._v("Canvas")])]),n._v(" "),e("h2",{attrs:{id:"效果"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#效果"}},[n._v("#")]),n._v(" 效果")]),n._v(" "),e("p",[n._v("这里我们说的效果主要是与鼠标之间的交互效果。")]),n._v(" "),e("p",[n._v("与鼠标之间有互动的效果主要是产生用户行为的反馈，比如在网页制作中，我们经常使用 hover 变色表示用户的鼠标在元素上方悬停。这就是用户行为的一种反馈。")]),n._v(" "),e("p",[n._v("我们经常使用的与鼠标之间的交互效果主要有两种：")]),n._v(" "),e("ul",[e("li",[n._v("鼠标跟随")]),n._v(" "),e("li",[n._v("视觉差")])]),n._v(" "),e("p",[n._v("我们来总结一下，炫酷的网页背景特效有哪些特点：")]),n._v(" "),e("ul",[e("li",[n._v("背景\n"),e("ul",[e("li",[n._v("单一颜色")]),n._v(" "),e("li",[n._v("渐变")]),n._v(" "),e("li",[n._v("平铺")])])]),n._v(" "),e("li",[n._v("炫酷\n"),e("ul",[e("li",[n._v("动")]),n._v(" "),e("li",[n._v("随机")])])]),n._v(" "),e("li",[n._v("特效（与用户交互）\n"),e("ul",[e("li",[n._v("鼠标跟随")]),n._v(" "),e("li",[n._v("视觉差")])])])]),n._v(" "),e("h2",{attrs:{id:"实现随机粒子特效"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现随机粒子特效"}},[n._v("#")]),n._v(" 实现随机粒子特效")]),n._v(" "),e("h4",{attrs:{id:"创建全屏-canvas"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建全屏-canvas"}},[n._v("#")]),n._v(" 创建全屏 Canvas")]),n._v(" "),e("p",[n._v("首先，我们需要一个全屏的 Canvas 画布。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n    <style>\n        html,body {\n            margin:0;\n            overflow:hidden;\n            width:100%;\n            height:100%;\n            cursor:none;\n            background:black;\n        }\n    </style>\n</head>\n<body>\n<canvas id="canvas"></canvas>\n\n<script>\n    var ctx = document.getElementById(\'canvas\'),\n        content = ctx.getContext(\'2d\'),\n        WIDTH,\n        HEIGHT;\n\n    WIDTH = document.documentElement.clientWidth;\n    HEIGHT = document.documentElement.clientHeight;\n\n    ctx.width = WIDTH;\n    ctx.height = HEIGHT;\n\n<\/script>\n</body>\n</html>\n\n')])])]),e("p",[n._v("我们使用 "),e("code",[n._v("WIDTH")]),n._v("、"),e("code",[n._v("HEIGHT")]),n._v(" 两个常量储存屏幕宽度和高度信息，我们习惯使用大写来表示改变量为常量，不可变，将屏幕宽度和高度信息储存在常量中是因为我们在稍后还会用到。")]),n._v(" "),e("p",[n._v("这时，你应该得到一个全屏的并且为黑色的 Canvas。")]),n._v(" "),e("h4",{attrs:{id:"设置-round-item-类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设置-round-item-类"}},[n._v("#")]),n._v(" 设置 Round_item 类")]),n._v(" "),e("p",[n._v("在创建了一个全屏的 Canvas 之后，我们来创建单个的 "),e("code",[n._v("Round_item")]),n._v(" 类。")]),n._v(" "),e("p",[n._v("首先我们 "),e("code",[n._v("Round_item")]),n._v(" 类需要有什么参数呢？我们要设置的是位置随机、透明度随机、半径随机的圆。为了区分不同的圆，我们还应该设置一个唯一的 "),e("code",[n._v("index")]),n._v(" 参数。")]),n._v(" "),e("p",[n._v("所以我们需要的参数有：")]),n._v(" "),e("ul",[e("li",[n._v("x 坐标")]),n._v(" "),e("li",[n._v("y 坐标")]),n._v(" "),e("li",[n._v("半径")]),n._v(" "),e("li",[n._v("透明度")]),n._v(" "),e("li",[n._v("index")])]),n._v(" "),e("p",[n._v("根据上面这些可以得出我们的 "),e("code",[n._v("Round_item")]),n._v(" 类：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('    function Round_item(index,x,y) {\n        this.index = index;\n        this.x = x;\n        this.y = y;\n        this.r = Math.random() * 2 + 1;\n        var alpha = (Math.floor(Math.random() * 10) + 1) / 10 / 2;\n        this.color = "rgba(255,255,255," + alpha + ")";\n    }\n\n')])])]),e("p",[n._v("这里我们使用了构造函数的方式来创建单个的圆，我们还需要一个变量 "),e("code",[n._v("initRoundPopulation")]),n._v(" 来设置 round 的个数，然后我们便可以通过 "),e("code",[n._v("for")]),n._v(" 循环创建出 "),e("code",[n._v("initRoundPopulation")]),n._v(" 个圆。")]),n._v(" "),e("h3",{attrs:{id:"设置-draw-方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设置-draw-方法"}},[n._v("#")]),n._v(" 设置 draw() 方法")]),n._v(" "),e("p",[n._v("在设置了单个的 "),e("code",[n._v("Round_item")]),n._v(" 类之后，我们还要给每一个 round 设置 "),e("code",[n._v("draw()")]),n._v(" 方法，所以我们需要将 "),e("code",[n._v("draw()")]),n._v(" 方法设置在 "),e("code",[n._v("Round_item")]),n._v(" 的原型中，这样我们创建出来的每一个 "),e("code",[n._v("Round_item")]),n._v(" 实例对象都拥有了 "),e("code",[n._v("draw()")]),n._v(" 方法。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("    Round_item.prototype.draw = function () {\n        content.fillStyle = this.color;\n        content.shadowBlur = this.r * 2;\n        content.beginPath();\n        content.arc(this.x, this.y, this.r, 0, 2 * Math.PI, false);\n        content.closePath();\n        content.fill();\n    };\n\n\n")])])]),e("h3",{attrs:{id:"设置初始化-init-函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设置初始化-init-函数"}},[n._v("#")]),n._v(" 设置初始化 init() 函数")]),n._v(" "),e("p",[n._v("然后我们就需要设置初始化 "),e("code",[n._v("init()")]),n._v(" 函数了，在 "),e("code",[n._v("init()")]),n._v(" 函数中，我们的主要任务是创建单个的 round，然后使用其 "),e("code",[n._v("draw()")]),n._v(" 方法。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("    function init() {\n        for(var i = 0; i < initRoundPopulation; i++ ){\n            round[i] = new Round_item(i,Math.random() * WIDTH,Math.random() * HEIGHT);\n            round[i].draw();\n        }\n\n    }\n\n")])])]),e("p",[n._v("至此，我们已经完成了随机粒子的实现，完整的代码如下：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('\n\n\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n    <style>\n        html,body {\n            margin:0;\n            overflow:hidden;\n            width:100%;\n            height:100%;\n            cursor:none;\n            background:black;\n        }\n    </style>\n</head>\n<body>\n<canvas id="canvas"></canvas>\n\n<script>\n    var ctx = document.getElementById(\'canvas\'),\n        content = ctx.getContext(\'2d\'),\n        round = [],\n        WIDTH,\n        HEIGHT,\n        initRoundPopulation = 100;\n\n\n    WIDTH = document.documentElement.clientWidth;\n    HEIGHT = document.documentElement.clientHeight;\n\n    ctx.width = WIDTH;\n    ctx.height = HEIGHT;\n\n    function Round_item(index,x,y) {\n        this.index = index;\n        this.x = x;\n        this.y = y;\n        this.r = Math.random() * 2 + 1;\n        var alpha = (Math.floor(Math.random() * 10) + 1) / 10 ;\n        let a=parseInt(255*Math.random());\n        let b=parseInt(255*Math.random());\n        let c=parseInt(255*Math.random());\n        this.color = `rgba(${a},${b},${c},${alpha} )`;\n    }\n\n    Round_item.prototype.draw = function () {\n        content.fillStyle = this.color;\n        content.shadowBlur = this.r * 2;\n        content.beginPath();\n        content.arc(this.x, this.y, this.r, 0, 2 * Math.PI, false);\n        content.closePath();\n        content.fill();\n    };\n\t\t\n\t\n\n    function init() {\n        for(var i = 0; i < initRoundPopulation; i++ ){\n            round[i] = new Round_item(i,Math.random() * WIDTH,Math.random() * HEIGHT);\n            round[i].draw();\n        }\n\n    }\n\n    init();\n\n<\/script>\n</body>\n</html>\n')])])]),e("h2",{attrs:{id:"使你的随机粒子动起来"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使你的随机粒子动起来"}},[n._v("#")]),n._v(" 使你的随机粒子动起来")]),n._v(" "),e("h4",{attrs:{id:"animate-函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#animate-函数"}},[n._v("#")]),n._v(" animate() 函数")]),n._v(" "),e("p",[n._v("其实，Canvas 制作动画是一个不断擦除再重绘的过程，跟最原始实现动画的方式类似。在纸片上画每一帧，然后以很快的速度翻动小本本，就会有动画的效果。")]),n._v(" "),e("p",[n._v("现在我们实现动画需要在很短的时间内不断的清除内容再重新绘制，新的图形和原先清除的图形之间有某种位置关系，速度足够快的话，我们就会看到动画的效果。")]),n._v(" "),e("p",[n._v("所以我们需要一个 "),e("code",[n._v("animate()")]),n._v(" 函数，这个函数的作用是帮助我们形成动画，我们在这个函数中首先需要清除当前屏幕，这里的清除函数用到的是 "),e("code",[n._v("content.clearRect()")]),n._v(" 方法。")]),n._v(" "),e("p",[n._v("我们先来看一下 canvas 的 "),e("code",[n._v("content.clearRect()")]),n._v(" 方法：")]),n._v(" "),e("p",[e("code",[n._v("context.clearRect(x,y,width,height);")])]),n._v(" "),e("ul",[e("li",[n._v("x：要清除的矩形左上角的 x 坐标")]),n._v(" "),e("li",[n._v("y：要清除的矩形左上角的 y 坐标")]),n._v(" "),e("li",[n._v("width：要清除的矩形的宽度，以像素计")]),n._v(" "),e("li",[n._v("height：要清除的矩形的高度，以像素计")])]),n._v(" "),e("p",[n._v("在刚刚的分析中可以得出，我们需要清除的区域是整个屏幕，所以 "),e("code",[n._v("content.clearRect()")]),n._v(" 的参数就是 "),e("code",[n._v("content.clearRect(0, 0, WIDTH, HEIGHT);")]),n._v("，这里我们就用到了之前获取的屏幕宽度和高度的常量："),e("code",[n._v("WIDTH")]),n._v(" 和 "),e("code",[n._v("HEIGHT")]),n._v("。这样我们就将屏幕上的所有内容都清除了。")]),n._v(" "),e("p",[n._v("清除了屏幕内容之后我们就要重新绘制图形，重新绘制的图形是需要和原图形之间有一定的关系，我们先制作一个简单的效果 —— 粒子匀速上升。粒子匀速上升，也就是 y 坐标在不断地变化，既然是匀速的，那么也就是在相同的时间位移是相同的。")]),n._v(" "),e("p",[n._v("我们将粒子位移的变化函数 "),e("code",[n._v("move()")]),n._v(" 写在 "),e("code",[n._v("Round_item")]),n._v(" 的原型上。稍后我们再实现。")]),n._v(" "),e("p",[n._v("重新绘制完图形之后，我们就完成了清除屏幕内容再重新绘制新的图形的任务。那么还需要有一个步骤 —— “ 不断”，要想实现动画的效果，就需要 “不断” 地进行清除再重绘，并且中间间隔的时间还不能过长。")]),n._v(" "),e("p",[e("code",[n._v("setTimeout")]),n._v(" 和 "),e("code",[n._v("setInterval")]),n._v(" 的问题是，它们都不精确。它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器 UI 线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行。")]),n._v(" "),e("p",[n._v("我们需要使用另外一个函数 —— "),e("code",[n._v("requestAnimationFrame()")]),n._v(" 。")]),n._v(" "),e("blockquote",[e("p",[e("code",[n._v("window.requestAnimationFrame()")]),n._v(" 方法告诉浏览器，你希望执行动画，并请求浏览器调用指定的函数在下一次重绘之前更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。")])]),n._v(" "),e("p",[e("code",[n._v("requestAnimationFrame()")]),n._v(" 函数可以说是专门用来写动画的。那么 "),e("code",[n._v("requestAnimationFrame()")]),n._v(" 有什么优点呢？")]),n._v(" "),e("blockquote",[e("p",[n._v("编写动画循环的关键是要知道延迟时间多长合适。一方面，循环间隔必须足够短，这样才能让不同的动画效果显得平滑流畅；另一方面，循环间隔还要足够长，这样才能确保浏览器有能力渲染产生的变化。")]),n._v(" "),e("p",[n._v("大多数电脑显示器的刷新频率是 60Hz，大概相当于每秒钟重绘 60 次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是 1000ms/60，约等于 16.6ms。")]),n._v(" "),e("p",[e("code",[n._v("requestAnimationFrame")]),n._v(" 采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。")])]),n._v(" "),e("p",[n._v("所以我们就使用 "),e("code",[n._v("requestAnimationFrame()")]),n._v(" 函数递归的调用 "),e("code",[n._v("animate()")]),n._v(" 函数来实现动画的效果。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("    function animate() {\n        content.clearRect(0, 0, WIDTH, HEIGHT);\n\n        for (var i in round) {\n            round[i].move();\n        }\n        requestAnimationFrame(animate);\n    }\n\n")])])]),e("h4",{attrs:{id:"创建-move-函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建-move-函数"}},[n._v("#")]),n._v(" 创建 "),e("code",[n._v("move()")]),n._v(" 函数")]),n._v(" "),e("p",[n._v("使用 "),e("code",[n._v("move()")]),n._v(" 函数来改变 round 的 y 坐标。那么我们就来实现一下。")]),n._v(" "),e("p",[n._v("在 "),e("code",[n._v("move()")]),n._v(" 方法中，我们只需要改变 round 的 y 坐标即可，并且设置边界条件，当 y 坐标的值小于 "),e("code",[n._v("-10")]),n._v("（也可以是其他负值），代表该 round 已经超出了屏幕，这个时候我们要将其移动到屏幕的最底端，这样才能保证我们创建的粒子数不变，一直是 "),e("code",[n._v("initRoundPopulation")]),n._v(" 的值。")]),n._v(" "),e("p",[n._v("这样就是一个粒子在不断地上升，上升到了最顶端再移动到最底端的循环过程，看起来像是有源源不断的粒子，但其实总数是不变的。")]),n._v(" "),e("p",[n._v("在 y 坐标的变化之后，我们还需要使用新的 y 坐标再来重新绘制一下该 round。")]),n._v(" "),e("p",[n._v("经过上面的分析，"),e("code",[n._v("move()")]),n._v(" 写起来是不是很简单呢？")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("    Round_item.prototype.move = function () {\n        this.y -= 0.15;\n        if (this.y <= -10) {\n            this.y = HEIGHT + 10;\n        }\n        this.draw();\n    };\n\n")])])]),e("h4",{attrs:{id:"在-init-中加入-animate"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在-init-中加入-animate"}},[n._v("#")]),n._v(" 在 "),e("code",[n._v("init()")]),n._v(" 中加入 "),e("code",[n._v("animate()")])]),n._v(" "),e("p",[n._v("我们想要实现动画的效果，还需要在 "),e("code",[n._v("init()")]),n._v(" 中加入 "),e("code",[n._v("animate()")]),n._v(" 函数。")]),n._v(" "),e("p",[n._v("最后，我们来看一下动画完整的实现代码吧:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n    <style>\n        html, body {\n            margin: 0;\n            overflow: hidden;\n            width: 100%;\n            height: 100%;\n            cursor: none;\n            background: black;\n        }\n    </style>\n</head>\n<body>\n<canvas id="canvas"></canvas>\n\n<script>\n    var ctx = document.getElementById(\'canvas\'),\n        content = ctx.getContext(\'2d\'),\n        round = [],\n        WIDTH,\n        HEIGHT,\n        initRoundPopulation = 60;\n\n\n    WIDTH = document.documentElement.clientWidth;\n    HEIGHT = document.documentElement.clientHeight;\n\n    ctx.width = WIDTH;\n    ctx.height = HEIGHT;\n\n    function Round_item(index, x, y) {\n        this.index = index;\n        this.x = x;\n        this.y = y;\n        this.r = Math.random() * 2 + 2;\n        var alpha = (Math.floor(Math.random() * 10) + 1) / 12 ;\n        let a=parseInt(255*Math.random());\n       let b=parseInt(255*Math.random());\n       let c=parseInt(255*Math.random());\n       this.color = `rgba(${a},${b},${c},${alpha})`;\n    }\n\n    Round_item.prototype.draw = function () {\n        content.fillStyle = this.color;\n        content.shadowBlur = this.r * 2;\n        content.beginPath();\n        content.arc(this.x, this.y, this.r, 0, 2 * Math.PI, false);\n        content.closePath();\n        content.fill();\n    };\n\n    function animate() {\n        content.clearRect(0, 0, WIDTH, HEIGHT);\n\n        for (var i in round) {\n            round[i].move();\n        }\n        requestAnimationFrame(animate)\n    }\n\n    Round_item.prototype.move = function () {\n        this.y -= 0.2;\n        if (this.y <= -10) {\n            this.y = HEIGHT + 10;\n        }\n        this.draw();\n    };\n\n\n    function init() {\n        for (var i = 0; i < initRoundPopulation; i++) {\n            round[i] = new Round_item(i, Math.random() * WIDTH, Math.random() * HEIGHT);\n            round[i].draw();\n        }\n        animate();\n\n    }\n\n    init();\n<\/script>\n</body>\n</html>\n\n\n')])])]),e("Gotop")],1)}),[],!1,null,null,null);t.default=i.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[202],{678:function(t,e,a){"use strict";a.r(e);var s=a(31),v=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"http"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[t._v("#")]),t._v(" http")]),t._v(" "),a("img",{attrs:{src:"/beifen/017.jpg"}}),t._v(" "),a("ul",[a("li",[t._v("物理层 主要作用定义物理设备如何传输数据")]),t._v(" "),a("li",[t._v("数据链路层 在通信的实体间建立数据链路连接")]),t._v(" "),a("li",[t._v("网络层 为数据在结点之间的传输创建逻辑链路")]),t._v(" "),a("li",[t._v("传输层 为用户提供可靠的端到端服务,传输层向高层屏蔽了下层数据通信的细节")]),t._v(" "),a("li",[t._v("应用层")])]),t._v(" "),a("h3",{attrs:{id:"http历程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http历程"}},[t._v("#")]),t._v(" http历程")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("HTTP/0.9\nHTTP是基于TCP/IP协议的应用层协议。它不涉及数据包传输，主要规定了客户端和服务器端之间的通信格式，默认使用80端口号。只有get命令。")])]),t._v(" "),a("li",[a("p",[t._v("HTTP/1.0\n任何格式的内容都可以发送，如文字、图片、视频、二进制文件。有get命令、post命令及head命令\nhttp请求和回应的格式也变了，除了数据部分，每次通信还包括头信息，描述一些元数据。还新增状态码、多字符集支持、多部分发送、权限、缓存、内容编码")])])]),t._v(" "),a("p",[t._v("请求格式：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("GET / HTTP/1.0\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)\nAccept: */*\n")])])]),a("p",[t._v("回应格式：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" HTTP/1.0 200 OK \nContent-Type: text/plain\nContent-Length: 137582\nExpires: Thu, 05 Dec 1997 16:00:00 GMT\nLast-Modified: Wed, 5 August 1996 15:55:28 GMT\nServer: Apache 0.84\n")])])]),a("p",[t._v("客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。如Accept: "),a("em",[t._v("/")]),t._v("，表示客户端可以接受任何类型的数据。")]),t._v(" "),a("p",[t._v("HTTP/1.0 版，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[a("p",[t._v("HTTP/1.1")]),t._v(" "),a("p",[t._v("引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive")]),t._v(" "),a("p",[t._v("户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。")]),t._v(" "),a("p",[t._v("对于同一个域名，大多数浏览器允许同时建立6个持久连接。")]),t._v(" "),a("p",[t._v("引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。")]),t._v(" "),a("p",[t._v("管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。")]),t._v(" "),a("p",[t._v("新增put、patch、head、option、delete；客户端请求的头信息新增host字段，用来指定服务器的域名。")])])]),t._v(" "),a("p",[t._v('虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为"队头堵塞"。两种方法：一是减少请求数，二是同时多开持久连接。如合并脚本和样式表、将图片嵌入CSS代码、域名分片等。')]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[a("p",[t._v("HTTP/2")]),t._v(" "),a("p",[t._v('HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。')]),t._v(" "),a("p",[t._v("二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧。")]),t._v(" "),a("p",[t._v('HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。如在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。这样双向的、实时的通信，称为多工。')]),t._v(" "),a("p",[t._v("HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。客户端还可以指定数据流的优先级。")]),t._v(" "),a("p",[t._v("引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。")]),t._v(" "),a("p",[t._v("HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。如客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。")])])]),t._v(" "),a("h3",{attrs:{id:"三次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),a("img",{attrs:{src:"/beifen/018.jpg"}}),t._v(" "),a("ul",[a("li",[t._v("seq：sequence number的缩写，表示所传数据的序号。TCP传输时每一个字节都有一个序号，发送数据时会将数据的第一个序号发送给对方，接收方会按序号检查是否接收完整了，如果没接收完就需要重新传送，这样就可以保证数据的完整性。")]),t._v(" "),a("li",[t._v("ack：acknoledgement number的缩写，表示确认号。接收端用它来给发送端反馈已经成功接收到的数据信息，它的值为希望接收的下一个数据包起始序号，也就是ack值所代表的序号前面数据已经成功接收到了。")]),t._v(" "),a("li",[t._v("ACK：确认位，只有ACK=1的时候ack才起作用。正常通信时ACK=1，第一次发起请求时因为没有需要确认接收的数据所以ACK为0。")]),t._v(" "),a("li",[t._v("SYN：同步位，用于在建立连接时同步序号。刚开始简历连接时并没有历史接收的数据，所以ack就没办法设置，这时按照正常的机制就无法运行了，SYN的作用就是来解决这个问题的，当接收端接收到SYN=1的报文时就会直接将ack设置为接收到的seq+1的值，注意这里的值并不是校验后设置的，而是根据SYN直接设置的，这样正常的机制就可以运行了，所以SYN叫同步位。需要注意的是，SYN会在前两次握手时都为1，这是因为通信的双方的ack都需要设置一个初始值。")]),t._v(" "),a("li",[t._v("FIN：终止位，用来在传输数据完毕后释放连接。")])]),t._v(" "),a("h3",{attrs:{id:"https和http使用过程中的可能的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#https和http使用过程中的可能的问题"}},[t._v("#")]),t._v(" https和http使用过程中的可能的问题")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Mixed Content: The page at '<URL>' was loaded over HTTPS, but requested an insecure XMLHttpRequest endpoint '<URL>'. This request has been blocked; the content must be served over HTTPS.\n")])])]),a("p",[t._v("在添加了SSL证书的HTTPS中引入用HTTP的链接，就报错，请求协议的不同导致的.所有有关https带有http的文件或者链接例如：images / js等文件都会报请求")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("“网页的“ < url > ”是通过 HTTPS 加载的，但是请求一个不安全的帧“ < url > ”。此请求已被阻止; 内容必须通过 HTTPS 提供。”\n")])])]),a("p",[t._v("解决方法：")]),t._v(" "),a("ul",[a("li",[t._v("第一种：查看http的文件，放到https路径中，引入方式添加https")]),t._v(" "),a("li",[t._v("第二种 页面的head中加入： "),a("code",[t._v('<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">')]),t._v("意思是自动将http的不安全请求升级为https (注意尽在需要的地方引入)\n结合第一二种一起解决")])])])}),[],!1,null,null,null);e.default=v.exports}}]);
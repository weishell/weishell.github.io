(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{498:function(a,n,t){"use strict";t.r(n);var s=t(43),o=Object(s.a)({},(function(){var a=this,n=a.$createElement,t=a._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"event-loop事件循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#event-loop事件循环"}},[a._v("#")]),a._v(" Event Loop事件循环")]),a._v(" "),t("h3",{attrs:{id:"线程和进程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程和进程"}},[a._v("#")]),a._v(" 线程和进程")]),a._v(" "),t("p",[a._v("本质上来说，两个名词都是 CPU 工作时间片的一个描述。")]),a._v(" "),t("p",[a._v("进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。线程是进程中的更小单位，描述了执行一段指令所需的时间。")]),a._v(" "),t("p",[a._v("把这些概念拿到浏览器中来说，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。")]),a._v(" "),t("p",[a._v("上文说到了 JS 引擎线程和渲染线程，大家应该都知道，在 JS 运行的时候可能会阻止 UI 渲染，这说明了两个线程是互斥的。这其中的原因是因为 JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。这其实也是一个单线程的好处，得益于 JS 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处。当然前面两点在服务端中更容易体现，对于锁的问题，形象的来说就是当我读取一个数字 15 的时候，同时有两个操作对数字进行了加减，这时候结果就出现了错误。解决这个问题也不难，只需要在读取的时候加锁，直到读取完毕之前都不能进行写入操作。")]),a._v(" "),t("h3",{attrs:{id:"执行栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行栈"}},[a._v("#")]),a._v(" 执行栈")]),a._v(" "),t("p",[a._v("可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。")]),a._v(" "),t("img",{attrs:{src:"/beifen/187.gif"}}),a._v(" "),t("p",[a._v("当开始执行 JS 代码时，首先会执行一个 main 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，在图中我们也可以发现，foo 函数后执行，当执行完毕后就从栈中弹出了。")]),a._v(" "),t("p",[a._v("平时在开发中，也可以在报错中找到执行栈的痕迹")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("throw")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Error")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'error'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("bar")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("bar")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("VM1004:2 Uncaught Error: error\n    at foo (<anonymous>:2:9)\n    at bar (<anonymous>:5:3)\n    at <anonymous>:7:1\n")])])]),t("p",[a._v("可以在上图清晰的看到报错在 foo 函数，foo 函数又是在 bar 函数中调用的。")]),a._v(" "),t("p",[a._v("当我们使用递归的时候，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("bar")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("bar")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("bar")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("VM1466:1 Uncaught RangeError: Maximum call stack size exceeded\n    at bar (<anonymous>:1:13)\n    at bar (<anonymous>:2:3)\n    at bar (<anonymous>:2:3)\n    at bar (<anonymous>:2:3)\n    at bar (<anonymous>:2:3)\n    at bar (<anonymous>:2:3)\n    at bar (<anonymous>:2:3)\n    at bar (<anonymous>:2:3)\n    at bar (<anonymous>:2:3)\n    at bar (<anonymous>:2:3)\n")])])]),t("h3",{attrs:{id:"浏览器中的事件循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器中的事件循环"}},[a._v("#")]),a._v(" 浏览器中的事件循环")]),a._v(" "),t("p",[a._v("当我们执行 JS 代码的时候其实就是往执行栈中放入函数，那么遇到异步代码的时候该怎么办？其实当遇到异步的代码时，会被挂起并在需要执行的时候加入到 Task（有多种 Task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。")]),a._v(" "),t("p",[a._v("不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。\n"),t("Gotop")],1),a._v(" "),t("p",[a._v("console.log('script start')")]),a._v(" "),t("p",[a._v("async function async1() {\nawait async2()\nconsole.log('async1 end')\n}\nasync function async2() {\nconsole.log('async2 end')\n}\nasync1()")]),a._v(" "),t("p",[a._v("setTimeout(function() {\nconsole.log('setTimeout')\n}, 0)")]),a._v(" "),t("p",[a._v("new Promise(resolve => {\nconsole.log('Promise')\nresolve()\n})\n.then(function() {\nconsole.log('promise1')\n})\n.then(function() {\nconsole.log('promise2')\n})")]),a._v(" "),t("p",[a._v("console.log('script end')")])])}),[],!1,null,null,null);n.default=o.exports}}]);
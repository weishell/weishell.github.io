(window.webpackJsonp=window.webpackJsonp||[]).push([[222],{623:function(t,a,s){"use strict";s.r(a);var e=s(16),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"内核"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内核"}},[t._v("#")]),t._v(" 内核")]),t._v(" "),a("p",[t._v("浏览器最重要或者说核心的部分是“Rendering Engine”，可大概译为“渲染引擎”，不过习惯将之称为“浏览器内核”。负责对网页语法的解释并渲染（显示）网页。")]),t._v(" "),a("h4",{attrs:{id:"trident"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#trident"}},[t._v("#")]),t._v(" Trident")]),t._v(" "),a("p",[t._v("Trident(IE内核)：沿用到IE11，'IE内核'。")]),t._v(" "),a("h4",{attrs:{id:"gecko"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gecko"}},[t._v("#")]),t._v(" Gecko")]),t._v(" "),a("p",[t._v("Gecko(Firefox内核)")]),t._v(" "),a("h4",{attrs:{id:"presto"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#presto"}},[t._v("#")]),t._v(" Presto")]),t._v(" "),a("p",[t._v("Presto(Opera前内核) (已废弃)：该款引擎的特点就是渲染速度的优化达到了极致，然而代价是牺牲了网页的兼容性。Opera现已改用Google Chrome的Blink内核。")]),t._v(" "),a("h4",{attrs:{id:"webkit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webkit"}},[t._v("#")]),t._v(" Webkit")]),t._v(" "),a("p",[t._v("Webkit(Safari内核,Chrome内核原型,开源)")]),t._v(" "),a("h4",{attrs:{id:"blink"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#blink"}},[t._v("#")]),t._v(" Blink")]),t._v(" "),a("p",[t._v("Blink是一个由Google和Opera Software开发的浏览器排版引擎。")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://note.youdao.com/s/cFLn6vni",target:"_blank",rel:"noopener noreferrer"}},[t._v("链接"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"浏览器内核理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器内核理解"}},[t._v("#")]),t._v(" 浏览器内核理解")]),t._v(" "),a("p",[t._v("主要分成两部分：渲染引擎(Layout Engine或Rendering Engine)和JS引擎。")]),t._v(" "),a("p",[t._v("渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。\nJS引擎：解析和执行javascript来实现网页的动态效果。")]),t._v(" "),a("p",[a("em",[a("strong",[t._v("最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。")])])]),t._v(" "),a("h2",{attrs:{id:"doctype"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#doctype"}},[t._v("#")]),t._v(" DOCTYPE")]),t._v(" "),a("p",[t._v("页面添加了"),a("code",[t._v("<!DOCTYPE html>")]),t._v("(注意：大小写不敏感)，那么就等同于开启了标准模式")]),t._v(" "),a("p",[t._v("Doctype：(Document Type)文档类型，它位于文档中最前面的位置，处于标签之前。\n告诉浏览器使用哪个版本的HTML规范来渲染文档。DOCTYPE不存在或形式不正确会导致HTML文档以混杂模式呈现。\n标准模式（Standards mode）以浏览器支持的最高标准运行；混杂模式（Quirks mode）中页面是一种比较宽松的向后兼容的方式显示。")]),t._v(" "),a("p",[t._v("HTML5不基于SGML（ "),a("strong",[t._v("Standard Generalized Markup Language 标准通用标记语言")]),t._v(" ），因此不需要对DTD（DTD "),a("strong",[t._v("Document Type Definition")]),t._v(" 文档类型定义）进行引用，但是需要DOCTYPE来规范浏览器行为。")]),t._v(" "),a("p",[t._v("HTML4.01基于SGML，所以需要引用DTD。才能告知浏览器文档所使用的文档类型，如下：")]),t._v(" "),a("div",{staticClass:"language-html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token doctype"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<!")]),a("span",{pre:!0,attrs:{class:"token doctype-tag"}},[t._v("DOCTYPE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token name"}},[t._v("HTML")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token name"}},[t._v("PUBLIC")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"-//W3C//DTD HTML 4.01//EN"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"http://www.w3.org/TR/html4/strict.dtd"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),a("ul",[a("li",[t._v("标准模式：浏览器按照 W3C 标准解析执行代码")]),t._v(" "),a("li",[t._v("怪异模式：浏览器根据自己的方式解析执行代码，因为不同浏览器解析,执行方式不一样，所以叫怪异模式")])]),t._v(" "),a("h4",{attrs:{id:"区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[t._v("#")]),t._v(" 区别：")]),t._v(" "),a("p",[t._v("(仅供参考，测试后发现有的已经不符合实际)")]),t._v(" "),a("ul",[a("li",[t._v("在怪异模式下，盒模型为怪异盒模型 而在标准模式下为标准盒子模型?")]),t._v(" "),a("li",[t._v("图片元素的垂直对齐方式对于行内元素和 table-cell 元素，标准模式下")]),t._v(" "),a("li",[t._v("vertical-align 属性默认值是 baseline，而在怪异模式下，table 单元格中的图片的 vertical-align 属性默认值是 bottom，因此在图片底部会有几像素的空间")]),t._v(" "),a("li",[t._v("元素中的字体css中font的属性都是可以继承的，怪异模式下，对于table元素，字体的某些元素不能从其他封装元素继承中得到，特别是 font-size属性")]),t._v(" "),a("li",[t._v("内联元素的尺寸标准模式下，non-replaced inline 元素无法自定义大写，怪异模式下，定义元素的宽高会影响元素的尺寸")]),t._v(" "),a("li",[t._v("元素的百分比高度当一个元素使用百分比高度时，在标准模式下，高度取决于内容变化，在怪异迷失下，百分比被准确应用")]),t._v(" "),a("li",[t._v("元素溢出的处理标准模式下，overflow 取值默认值为 visible，在怪异模式下，这个溢出会被当做扩展 box 对待，就是元素的大小由内容决定，溢出不会裁剪，元素框自动调整，包含溢出内容")])]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/htmlcss/basic/018compatMode.html#document-compatmode"}},[t._v("查看当前模式")]),t._v(":document.compatMode")],1),t._v(" "),a("h2",{attrs:{id:"html5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#html5"}},[t._v("#")]),t._v(" HTML5")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("+ 代码层面：语义化标签\n+ 提升用户交互输入：提供各种类型的输入选择器，输入框新属性，定位\n+ 提升页面渲染输出：音频，视频，SVG，canvas，embed\n+ 增强浏览器性能和功能：websocket，webworker，stroage\n+ 拖放drag\n")])])]),a("p",[t._v("新增加了图像、位置、存储、多任务等功能。\n新增元素：")]),t._v(" "),a("ul",[a("li",[t._v("canvas")]),t._v(" "),a("li",[t._v("video和audio元素")]),t._v(" "),a("li",[t._v("本地离线存储。localStorage  sessionStorage")]),t._v(" "),a("li",[t._v("语意化更好的内容元素，比如 article footer header nav section")]),t._v(" "),a("li",[t._v("位置API：Geolocation")]),t._v(" "),a("li",[t._v("表单控件，calendar date time email url search")]),t._v(" "),a("li",[t._v("新的技术：web worker(web worker是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行) web socket")]),t._v(" "),a("li",[t._v("拖放API：drag、drop")])]),t._v(" "),a("p",[t._v("移除的元素：")]),t._v(" "),a("ul",[a("li",[t._v("纯表现的元素：basefont big center font s strike tt u")]),t._v(" "),a("li",[t._v("性能较差元素：frame frameset noframes")])]),t._v(" "),a("h4",{attrs:{id:"区分h5与html"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#区分h5与html"}},[t._v("#")]),t._v(" 区分H5与html")]),t._v(" "),a("ul",[a("li",[t._v("DOCTYPE声明的方式是区分重要因素")]),t._v(" "),a("li",[t._v("根据新增加的结构、功能来区分")])]),t._v(" "),a("h3",{attrs:{id:"title与h1的区别、b与strong的区别、i与em的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#title与h1的区别、b与strong的区别、i与em的区别"}},[t._v("#")]),t._v(" title与h1的区别、b与strong的区别、i与em的区别")]),t._v(" "),a("ol",[a("li",[t._v("title属性没有明确意义，只表示标题；h1表示层次明确的标题，对页面信息的抓取也有很大的影响")]),t._v(" "),a("li",[t._v("strong标明重点内容，语气加强含义；b是无意义的视觉表示")]),t._v(" "),a("li",[t._v("em表示强调文本；i是斜体，是无意义的视觉表示")]),t._v(" "),a("li",[t._v("视觉样式标签：b i u s")]),t._v(" "),a("li",[t._v("语义样式标签："),a("strong",[t._v("strong em ins del code")])])]),t._v(" "),a("h3",{attrs:{id:"前端页面有哪三层构成-分别是什么-作用是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端页面有哪三层构成-分别是什么-作用是什么"}},[t._v("#")]),t._v(" 前端页面有哪三层构成，分别是什么?作用是什么?")]),t._v(" "),a("p",[t._v("结构层、表示层、行为层。")]),t._v(" "),a("p",[t._v("网页的结构层（structural layer）由 HTML 或 XHTML 之类的标记语言负责创建。")]),t._v(" "),a("p",[t._v("网页的表示层（presentation layer） 由 CSS 负责创建。")]),t._v(" "),a("p",[t._v("网页的行为层（behavior layer） Javascript 语言和 DOM 主宰的领域。")]),t._v(" "),a("h3",{attrs:{id:"html标签滥用影响"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#html标签滥用影响"}},[t._v("#")]),t._v(" HTML标签滥用影响")]),t._v(" "),a("p",[t._v("不恰当地使用语义标签，反而会造成负面作用。\n如ul多数出现正在行文中间，它的上文多数在提示：要列举某些项。但是，如果所有并列关系都用\nul ，会造成大量冗余标签。\n"),a("strong",[t._v("错误地使用语义标签，会给机器阅读造成混淆、增加嵌套，给 CSS 编写加重负担。")])]),t._v(" "),a("h3",{attrs:{id:"行内元素换行写有间隙的原因及解决办法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#行内元素换行写有间隙的原因及解决办法"}},[t._v("#")]),t._v(" 行内元素换行写有间隙的原因及解决办法")]),t._v(" "),a("p",[t._v("行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。")]),t._v(" "),a("h3",{attrs:{id:"a标签伪类顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#a标签伪类顺序"}},[t._v("#")]),t._v(" a标签伪类顺序")]),t._v(" "),a("p",[t._v("上面是伪类的正确顺序，简称 lvha(love-ha)。你一直知道这个顺序但是为什么这样呢？原理是怎么样的？")]),t._v(" "),a("div",{staticClass:"language-css extra-class"},[a("pre",{pre:!0,attrs:{class:"language-css"}},[a("code",[a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("a:link")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("#f30"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("a:visited")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("#000"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("a:hover")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("#fff"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token selector"}},[t._v("a:active")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("#f99"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("首先伪类的特殊性（应用优先级）是同样的，所以后出现的伪类会覆盖先出现的伪类（同时激活）")]),t._v(" "),a("p",[t._v("lvha 规则是由于CSS特殊性导致，css特殊性有一个按顺序的规则（同一条css规则，后出现会覆盖前面的同样规则）\n在这里，比如把hover放在active后面，那么实际你在激活（active）链接的时候就触发了hover伪类，hover在后面覆盖了active的颜色，所以始终无法看到active的颜色\n如果把visited放在hover的后面，那么已经访问过的链接始终触发visited伪类，根据第一条会覆盖hover里面的颜色。")]),t._v(" "),a("p",[t._v("其实 link visited 这两个伪类，并不需要顺序关系。（他们两的位置可以交换）")])])}),[],!1,null,null,null);a.default=r.exports}}]);
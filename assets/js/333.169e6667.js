(window.webpackJsonp=window.webpackJsonp||[]).push([[333],{443:function(a,t,s){"use strict";s.r(t);var e=s(43),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"webpack"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[a._v("#")]),a._v(" webpack")]),a._v(" "),s("p",[a._v("webpack是一个打包模块化javascript的工具，在webpack里一切文件皆模块，通过loader转换文件，通过plugin注入钩子，最后输出由多个模块组合成的文件，webpack专注构建模块化项目。")]),a._v(" "),s("p",[a._v("WebPack可以看做是模块打包机：它做的事情是，分析项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。")]),a._v(" "),s("h3",{attrs:{id:"webpack五个核心概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack五个核心概念"}},[a._v("#")]),a._v(" webpack五个核心概念")]),a._v(" "),s("ul",[s("li",[a._v("Entry")]),a._v(" "),s("li",[a._v("Output")]),a._v(" "),s("li",[a._v("Loader")]),a._v(" "),s("li",[a._v("Plugins")]),a._v(" "),s("li",[a._v("Mode")])]),a._v(" "),s("p",[a._v("webpack只能人事js和json且能将模块化转为浏览器可识别的结构，像css，img等就需要通过加载loader转化成它可以识别的内容")]),a._v(" "),s("p",[a._v("最基本的运行指令")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("webpack ./src/index.js -o ./build/built.js --mode=development\nwebpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js\n整体打包环境，是开发环境\n\nwebpack ./src/index.js -o ./build/built.js --mode=production\n")])])]),s("h3",{attrs:{id:"几个常见的loader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#几个常见的loader"}},[a._v("#")]),a._v(" 几个常见的loader")]),a._v(" "),s("ul",[s("li",[a._v("file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件")]),a._v(" "),s("li",[a._v("url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去")]),a._v(" "),s("li",[a._v("image-loader：加载并且压缩图片文件")]),a._v(" "),s("li",[a._v("babel-loader：把 ES6 转换成 ES5")]),a._v(" "),s("li",[a._v("css-loader：加载 CSS，支持模块化、压缩、文件导入等特性")]),a._v(" "),s("li",[a._v("style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。")]),a._v(" "),s("li",[a._v("eslint-loader：通过 ESLint 检查 JavaScript 代码")])]),a._v(" "),s("h3",{attrs:{id:"几个常见的plugin"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#几个常见的plugin"}},[a._v("#")]),a._v(" 几个常见的plugin")]),a._v(" "),s("ul",[s("li",[a._v("define-plugin：定义环境变量")]),a._v(" "),s("li",[a._v("terser-webpack-plugin：通过TerserPlugin压缩ES6代码")]),a._v(" "),s("li",[a._v("html-webpack-plugin 为html文件中引入的外部资源，可以生成创建html入口文件")]),a._v(" "),s("li",[a._v("mini-css-extract-plugin：分离css文件")]),a._v(" "),s("li",[a._v("clean-webpack-plugin：删除打包文件")]),a._v(" "),s("li",[a._v("happypack：实现多线程加速编译")])]),a._v(" "),s("h3",{attrs:{id:"webpack与grunt、gulp的不同？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack与grunt、gulp的不同？"}},[a._v("#")]),a._v(" webpack与grunt、gulp的不同？")]),a._v(" "),s("p",[a._v("Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案。")]),a._v(" "),s("p",[a._v("它们的工作方式也有较大区别：\nGrunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等具体步骤，工具之后可以自动完成这些任务。")]),a._v(" "),s("p",[a._v("Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。")]),a._v(" "),s("p",[a._v("grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。")]),a._v(" "),s("p",[a._v("webpack是基于"),s("code",[a._v("入口")]),a._v("的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。")]),a._v(" "),s("p",[a._v("所以总结一下：")]),a._v(" "),s("p",[a._v("从构建思路来说")]),a._v(" "),s("p",[a._v("gulp和grunt需要开发者将整个前端构建过程拆分成多个Task，并合理控制所有Task的调用关系\nwebpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工")]),a._v(" "),s("p",[a._v("对于知识背景来说")]),a._v(" "),s("p",[a._v("gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路")]),a._v(" "),s("h4",{attrs:{id:"webpack有哪些优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack有哪些优点"}},[a._v("#")]),a._v(" webpack有哪些优点")]),a._v(" "),s("ul",[s("li",[a._v("专注于处理模块化的项目，能做到开箱即用，一步到位")]),a._v(" "),s("li",[a._v("可通过plugin扩展，完整好用又不失灵活")]),a._v(" "),s("li",[a._v("使用场景不局限于web开发")])]),a._v(" "),s("h4",{attrs:{id:"webpack的缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack的缺点"}},[a._v("#")]),a._v(" webpack的缺点")]),a._v(" "),s("p",[a._v("webpack的缺点是只能用于采用模块化开发的项目")]),a._v(" "),s("h4",{attrs:{id:"分别介绍bundle，chunk，module是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分别介绍bundle，chunk，module是什么"}},[a._v("#")]),a._v(" 分别介绍bundle，chunk，module是什么")]),a._v(" "),s("ul",[s("li",[a._v("bundle：是由webpack打包出来的文件，")]),a._v(" "),s("li",[a._v("chunk：代码块，一个chunk由多个模块组合而成，用于代码的合并和分割。")]),a._v(" "),s("li",[a._v("module：是开发中的单个模块，在webpack的世界，一切皆模块，一个模块对应一个文件，webpack会从配置的entry中递归开始找出所有依赖的模块。")])]),a._v(" "),s("h4",{attrs:{id:"分别介绍什么是loader-什么是plugin"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分别介绍什么是loader-什么是plugin"}},[a._v("#")]),a._v(" 分别介绍什么是loader?什么是plugin?")]),a._v(" "),s("ul",[s("li",[a._v("loader：模块转换器，用于将模块的原内容按照需要转成你想要的内容")]),a._v(" "),s("li",[a._v("plugin：在webpack构建流程中的特定时机注入扩展逻辑，来改变构建结果，是用来自定义webpack打包过程的方式，一个插件是含有apply方法的一个对象，通过这个方法可以参与到整个webpack打包的各个流程(生命周期)。")])]),a._v(" "),s("h4",{attrs:{id:"模块热更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块热更新"}},[a._v("#")]),a._v(" 模块热更新")]),a._v(" "),s("p",[a._v("模块热更新是webpack的一个功能，他可以使得代码修改过后不用刷新浏览器就可以更新，是高级版的自动刷新浏览器。")]),a._v(" "),s("p",[a._v("1.通过配置文件")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[a._v(" devServer"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n     hot"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),a._v("\n "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("ol",{attrs:{start:"2"}},[s("li",[a._v("通过命令行")])]),a._v(" "),s("div",{staticClass:"language-json extra-class"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[a._v("  "),s("span",{pre:!0,attrs:{class:"token property"}},[a._v('"scripts"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[a._v('"start"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"NODE_ENV=development  webpack-dev-server --config  webpack.develop.config.js --hot"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n")])])]),s("h4",{attrs:{id:"什么是tree-shaking"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是tree-shaking"}},[a._v("#")]),a._v(" 什么是Tree-shaking")]),a._v(" "),s("p",[a._v("Tree-shaking可以用来剔除javascript中不用的死代码，它依赖静态的es6模块化语法，css中使用Tree-shaking需要引入Purify-CSS")]),a._v(" "),s("h4",{attrs:{id:"通过webpack处理长缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#通过webpack处理长缓存"}},[a._v("#")]),a._v(" 通过webpack处理长缓存")]),a._v(" "),s("p",[a._v("为了加快加载速度，会对用户访问的静态资源进行存储，但是每一次代码升级或是更新，都需要浏览器去下载新的代码，最方便和简单的更新方式就是引入新的文件名称。在webpack中可以在output纵输出的文件指定chunkhash,并且分离经常更新的代码和框架代码。通过NameModulesPlugin或是HashedModuleIdsPlugin使再次打包文件名不变。")]),a._v(" "),s("h4",{attrs:{id:"如何提高webpack的构建速度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何提高webpack的构建速度"}},[a._v("#")]),a._v(" 如何提高webpack的构建速度")]),a._v(" "),s("ul",[s("li",[a._v("通过externals配置来提取常用库")]),a._v(" "),s("li",[a._v("利用DllPlugin和DllReferencePlugin预编译资源模块 通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来。")]),a._v(" "),s("li",[a._v("使用Happypack 实现多线程加速编译")])]),a._v(" "),s("p",[a._v("要注意的第一点是，它对file-loader和url-loader支持不好，所以这两个loader就不需要换成happypack了，其他loader可以类似地换一下")]),a._v(" "),s("ul",[s("li",[a._v("使用Tree-shaking和Scope Hoisting来剔除多余代码")]),a._v(" "),s("li",[a._v("使用fast-sass-loader代替sass-loader")]),a._v(" "),s("li",[a._v("babel-loader开启缓存")]),a._v(" "),s("li",[a._v("babel-loader在执行的时候，可能会产生一些运行期间重复的公共文件，造成代码体积大冗余，同时也会减慢编译效率")]),a._v(" "),s("li",[a._v("可以加上cacheDirectory参数或使用 transform-runtime 插件试试")])]),a._v(" "),s("p",[a._v('不需要打包编译的插件库换成全局"script"标签引入的方式\n比如jQuery插件，react, react-dom等，代码量是很多的，打包起来可能会很耗时\n可以直接用标签引入，然后在webpack配置里使用 expose-loader 或 externals 或 ProvidePlugin 提供给模块内部使用相应的变量')]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// @1")]),a._v("\nuse"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    loader"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'expose-loader'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n    options"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'$'")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    loader"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'expose-loader'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n    options"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'jQuery'")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// @2")]),a._v("\nexternals"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        jquery"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'jQuery'")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// @3")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("webpack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("ProvidePlugin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            $"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'jquery'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n            jQuery"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'jquery'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'window.jQuery'")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'jquery'")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n")])])]),s("h4",{attrs:{id:"优化构建时的搜索路径"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化构建时的搜索路径"}},[a._v("#")]),a._v(" 优化构建时的搜索路径")]),a._v(" "),s("p",[a._v("在webpack打包时，会有各种各样的路径要去查询搜索，我们可以加上一些配置，让它搜索地更快\n比如说，方便改成绝对路径的模块路径就改一下，以纯模块名来引入的可以加上一些目录路径\n还可以善于用下resolve alias别名 这个字段来配置\n还有exclude等的配置，避免多余查找的文件，比如使用babel别忘了剔除不需要遍历的")]),a._v(" "),s("h4",{attrs:{id:"寻找到引入文件的位置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#寻找到引入文件的位置"}},[a._v("#")]),a._v(" 寻找到引入文件的位置")]),a._v(" "),s("p",[a._v("在 webpack 支持的前端代码模块化中，我们可以使用类似 import * as m from './index.js' 来引用代码模块 index.js。")]),a._v(" "),s("p",[a._v("引用第三方类库则是像这样：import React from 'react'。webpack 构建的时候，会解析依赖后，然后再去加载依赖的模块文件，那么 webpack 如何将上述编写的 ./index.js 或 react 解析成对应的模块文件路径呢？")]),a._v(" "),s("p",[a._v("webpack 中有一个很关键的模块 "),s("code",[a._v("enhanced-resolve")]),a._v("就是处理依赖模块路径的解析的，这个模块可以说是 Node.js 那一套模块路径解析的增强版本，有很多可以自定义的解析配置。")]),a._v(" "),s("Gotop")],1)}),[],!1,null,null,null);t.default=r.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{372:function(t,a,e){"use strict";e.r(a);var r=e(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("div",{staticClass:"content"},[e("h2",{attrs:{id:"内核"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内核","aria-hidden":"true"}},[t._v("#")]),t._v(" 内核")]),t._v(" "),e("p",[t._v("浏览器最重要或者说核心的部分是“Rendering Engine”，可大概译为“渲染引擎”，不过我们一般习惯将之称为“浏览器内核”。负责对网页语法的解释（如标准通用标记语言下的一个应用HTML、JavaScript）并渲染（显示）网页。")]),t._v(" "),e("h4",{attrs:{id:"trident"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#trident","aria-hidden":"true"}},[t._v("#")]),t._v(" Trident")]),t._v(" "),e("p",[t._v("Trident(IE内核)：沿用到IE11，也被普遍称作'IE内核'。")]),t._v(" "),e("h4",{attrs:{id:"gecko"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gecko","aria-hidden":"true"}},[t._v("#")]),t._v(" Gecko")]),t._v(" "),e("p",[t._v("Gecko(Firefox内核)：Netscape6开始采用的内核，后来的Mozilla FireFox(火狐浏览器) 也采用了该内核。")]),t._v(" "),e("h4",{attrs:{id:"presto"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#presto","aria-hidden":"true"}},[t._v("#")]),t._v(" Presto")]),t._v(" "),e("p",[t._v("Presto(Opera前内核) (已废弃)：该款引擎的特点就是渲染速度的优化达到了极致，然而代价是牺牲了网页的兼容性。Opera现已改用Google Chrome的Blink内核。")]),t._v(" "),e("h4",{attrs:{id:"webkit"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webkit","aria-hidden":"true"}},[t._v("#")]),t._v(" Webkit")]),t._v(" "),e("p",[t._v("Webkit(Safari内核,Chrome内核原型,开源):它是苹果公司自己的内核，也是苹果的Safari浏览器使用的内核。")]),t._v(" "),e("p",[t._v("WebKit内核常见的浏览器：Apple Safari (Win/Mac/iPhone/iPad)、Android 默认浏览器")]),t._v(" "),e("h4",{attrs:{id:"blink"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#blink","aria-hidden":"true"}},[t._v("#")]),t._v(" Blink")]),t._v(" "),e("p",[t._v("Blink是一个由Google和Opera Software开发的浏览器排版引擎，Google计划将这个渲染引擎作为Chromium计划的一部分，并且在2013年4月的时候公布了这一消息。")]),t._v(" "),e("h2",{attrs:{id:"浏览器内核理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器内核理解","aria-hidden":"true"}},[t._v("#")]),t._v(" 浏览器内核理解")]),t._v(" "),e("p",[t._v("主要分成两部分：渲染引擎(Layout Engine或Rendering Engine)和JS引擎。")]),t._v(" "),e("p",[t._v("渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。\nJS引擎：解析和执行javascript来实现网页的动态效果。")]),t._v(" "),e("p",[t._v("最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。")]),t._v(" "),e("h2",{attrs:{id:"doctype"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#doctype","aria-hidden":"true"}},[t._v("#")]),t._v(" DOCTYPE")]),t._v(" "),e("p",[t._v("Doctype：(Document Type)文档类型，它位于文档中最前面的位置，处于标签之前。\n告诉浏览器使用哪个版本的HTML规范来渲染文档。DOCTYPE不存在或形式不正确会导致HTML文档以混杂模式呈现。\n标准模式（Standards mode）以浏览器支持的最高标准运行；混杂模式（Quirks mode）中页面是一种比较宽松的向后兼容的方式显示。")]),t._v(" "),e("p",[t._v("HTML5不基于SGML（ "),e("strong",[t._v("Standard Generalized Markup Language 标准通用标记语言")]),t._v(" ），因此不需要对DTD（DTD "),e("strong",[t._v("Document Type Definition")]),t._v(" 文档类型定义）进行引用，但是需要DOCTYPE来规范浏览器行为。")]),t._v(" "),e("p",[t._v("HTML4.01基于SGML，所以需要引用DTD。才能告知浏览器文档所使用的文档类型，如下：")]),t._v(" "),e("div",{staticClass:"language-html extra-class"},[e("pre",{pre:!0,attrs:{class:"language-html"}},[e("code",[e("span",{pre:!0,attrs:{class:"token doctype"}},[t._v('<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">')]),t._v("\n")])])]),e("h2",{attrs:{id:"html5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html5","aria-hidden":"true"}},[t._v("#")]),t._v(" HTML5")]),t._v(" "),e("p",[t._v("新增加了图像、位置、存储、多任务等功能。\n新增元素：")]),t._v(" "),e("ul",[e("li",[t._v("canvas")]),t._v(" "),e("li",[t._v("用于媒介回放的video和audio元素")]),t._v(" "),e("li",[t._v("本地离线存储。localStorage长期存储数据，浏览器关闭后数据不丢失;sessionStorage的数据在浏览器关闭后自动删除")]),t._v(" "),e("li",[t._v("语意化更好的内容元素，比如 article footer header nav section")]),t._v(" "),e("li",[t._v("位置API：Geolocation")]),t._v(" "),e("li",[t._v("表单控件，calendar date time email url search")]),t._v(" "),e("li",[t._v("新的技术：web worker(web worker是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行) web socket")]),t._v(" "),e("li",[t._v("拖放API：drag、drop")])]),t._v(" "),e("p",[t._v("移除的元素：")]),t._v(" "),e("ul",[e("li",[t._v("纯表现的元素：basefont big center font s strike tt u")]),t._v(" "),e("li",[t._v("性能较差元素：frame frameset noframes")])]),t._v(" "),e("h4",{attrs:{id:"区分h5与html"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#区分h5与html","aria-hidden":"true"}},[t._v("#")]),t._v(" 区分H5与html")]),t._v(" "),e("ul",[e("li",[t._v("DOCTYPE声明的方式是区分重要因素")]),t._v(" "),e("li",[t._v("根据新增加的结构、功能来区分")])]),t._v(" "),e("h3",{attrs:{id:"html语义化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html语义化","aria-hidden":"true"}},[t._v("#")]),t._v(" HTML语义化")]),t._v(" "),e("ol",[e("li",[t._v("去掉或丢失样式的时候能够让页面呈现出清晰的结构。")]),t._v(" "),e("li",[t._v("有利于SEO和搜索引擎建立良好沟通，有助于爬虫抓取更多的信息，爬虫依赖于标签来确定上下文和各个关键字的权重。")]),t._v(" "),e("li",[t._v("方便其它设备解析。")]),t._v(" "),e("li",[t._v("便于团队开发和维护，语义化根据可读性。")])]),t._v(" "),e("h3",{attrs:{id:"title与h1的区别、b与strong的区别、i与em的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#title与h1的区别、b与strong的区别、i与em的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" title与h1的区别、b与strong的区别、i与em的区别")]),t._v(" "),e("ol",[e("li",[t._v("title属性没有明确意义，只表示标题；h1表示层次明确的标题，对页面信息的抓取也有很大的影响")]),t._v(" "),e("li",[t._v("strong标明重点内容，语气加强含义；b是无意义的视觉表示")]),t._v(" "),e("li",[t._v("em表示强调文本；i是斜体，是无意义的视觉表示")]),t._v(" "),e("li",[t._v("视觉样式标签：b i u s")]),t._v(" "),e("li",[t._v("语义样式标签："),e("strong",[t._v("strong em ins del code")])])]),t._v(" "),e("h3",{attrs:{id:"前端页面有哪三层构成，分别是什么-作用是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端页面有哪三层构成，分别是什么-作用是什么","aria-hidden":"true"}},[t._v("#")]),t._v(" 前端页面有哪三层构成，分别是什么?作用是什么?")]),t._v(" "),e("p",[t._v("结构层、表示层、行为层。")]),t._v(" "),e("p",[t._v("网页的结构层（structural layer）由 HTML 或 XHTML 之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P 标签表达了这样一种语义：“这是一个文本段。”")]),t._v(" "),e("p",[t._v("网页的表示层（presentation layer） 由 CSS 负责创建。 CSS 对“如何显示有关内容”的问题做出了回答。")]),t._v(" "),e("p",[t._v("网页的行为层（behavior layer）负责回答“内容应该如何对事件做出反应”这一问题。这是 Javascript 语言和 DOM 主宰的领域。")]),t._v(" "),e("h3",{attrs:{id:"html标签滥用影响"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html标签滥用影响","aria-hidden":"true"}},[t._v("#")]),t._v(" HTML标签滥用影响")]),t._v(" "),e("p",[t._v("不恰当地使用语义标签，反而会造成负面作用。这里我们举一个常见的误区作为例子。我\n们都知道 ul 是无序列表， ol 是有序列表，所以很多接触过语义这个概念，半懂不懂的前端工程\n师，特别喜欢给所有并列关系的元素都套上 ul 。\n实际上， ul  是长成下面的这种样子的 ( 以下来自 HTML 标准 ) 。")]),t._v(" "),e("div",{staticClass:"language-html extra-class"},[e("pre",{pre:!0,attrs:{class:"language-html"}},[e("code",[t._v("I have lived in the following countries:\n·Switzerland\n·Norway\n·United Kingdom\n·United States\n")])])]),e("p",[t._v("ul 多数出现正在行文中间，它的上文多数在提示：要列举某些项。但是，如果所有并列关系都用\nul ，会造成大量冗余标签。\n"),e("strong",[t._v("错误地使用语义标签，会给机器阅读造成混淆、增加嵌套，给 CSS 编写加重负担。")])]),t._v(" "),e("h3",{attrs:{id:"行内元素换行写有间隙的原因及解决办法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#行内元素换行写有间隙的原因及解决办法","aria-hidden":"true"}},[t._v("#")]),t._v(" 行内元素换行写有间隙的原因及解决办法")]),t._v(" "),e("p",[t._v("行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。")]),t._v(" "),e("h3",{attrs:{id:"a标签伪类顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#a标签伪类顺序","aria-hidden":"true"}},[t._v("#")]),t._v(" a标签伪类顺序")]),t._v(" "),e("p",[t._v("上面是伪类的正确顺序，简称 lvha(love-ha)。你一直知道这个顺序但是为什么这样呢？原理是怎么样的？")]),t._v(" "),e("div",{staticClass:"language-css extra-class"},[e("pre",{pre:!0,attrs:{class:"language-css"}},[e("code",[e("span",{pre:!0,attrs:{class:"token selector"}},[t._v("a:link")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("#f30"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n"),e("span",{pre:!0,attrs:{class:"token selector"}},[t._v("a:visited")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("#000"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n"),e("span",{pre:!0,attrs:{class:"token selector"}},[t._v("a:hover")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("#fff"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n"),e("span",{pre:!0,attrs:{class:"token selector"}},[t._v("a:active")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token property"}},[t._v("color")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("#f99"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("首先伪类的特殊性（应用优先级）是同样的，所以后出现的伪类会覆盖先出现的伪类（同时激活）")]),t._v(" "),e("p",[t._v("lvha 规则是由于CSS特殊性导致，css特殊性有一个按顺序的规则（同一条css规则，后出现会覆盖前面的同样规则）\n在这里，比如把hover放在active后面，那么实际你在激活（active）链接的时候就触发了hover伪类，hover在后面覆盖了active的颜色，所以始终无法看到active的颜色\n如果把visited放在hover的后面，那么已经访问过的链接始终触发visited伪类，根据第一条会覆盖hover里面的颜色。")]),t._v(" "),e("p",[t._v("其实 link visited 这两个伪类，并不需要顺序关系。（他们两的位置可以交换）")])])}],!1,null,null,null);a.default=s.exports}}]);
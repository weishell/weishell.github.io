(window.webpackJsonp=window.webpackJsonp||[]).push([[377],{784:function(a,s,t){"use strict";t.r(s);var e=t(16),r=Object(e.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"js相关案例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js相关案例"}},[a._v("#")]),a._v(" js相关案例")]),a._v(" "),s("h3",{attrs:{id:"js-js兼容-polyfill-方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js-js兼容-polyfill-方案"}},[a._v("#")]),a._v(" [js]js兼容(polyfill)方案")]),a._v(" "),s("Open",[s("p",[a._v("如老版本浏览器不支持数组find方法")]),a._v(" "),s("ol",[s("li",[a._v("引入polyfill文件来模拟对这些api的支持，这种方式通过为旧的浏览器添加新的api，来达到兼容的目的。")])]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("find "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("find "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("||")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("predicate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("当Array.prototype.find不存在时，就执行后面的表达式，在这个时候，就需要了解有哪些特性，去引入相关的兼容代码，不贵会导致构建出来的polyfill变得庞大，这种方案只能解决缺失api的情况，当要使用一些新的语法特性，如箭头函数则需要使用转译的方案实现。")]),a._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[a._v("转译(Transpilig)，即通过使用babel等工具，将es6代码转换为es5代码，然后再进行打包，这种方案可以解决缺失api和语法特性的问题，但是需要引入babel等工具，并且需要配置，比较麻烦。")])])]),a._v(" "),s("h3",{attrs:{id:"js-说说微前端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js-说说微前端"}},[a._v("#")]),a._v(" [js]说说微前端")]),a._v(" "),s("Open",[s("p",[a._v("微前端是一种类似于微服务的架构，它是将前端应用拆分成多个子应用，每个子应用都可以独立运行，并通过微前端框架来管理子应用的交互。")]),a._v(" "),s("p",[s("strong",[a._v("应用自治，单一职责，技术栈无关。")])]),a._v(" "),s("p",[a._v("拆分方式：")]),a._v(" "),s("p",[a._v("1."),s("code",[a._v("路由分发式")]),a._v("：通过http服务器反向代理，将请求路由到对应的应用上（用的最多，最容易的方案）,看上去更像是多个前端应用的聚合，只是将不同的前端应用拼凑到一起，看上去像个整体，但是如果用户从A应用到B应用，往往需要刷新页面，重新加载资源。在这个架构中，只需要关注应用间数据传递方式，通常，只需要将当前用户状态从A应用中传递到B应用即可，如果两个应用在同一个域里，就更方便了。可以使用localstorange/cookie/indexdb等数据共享，"),s("code",[a._v("缺点是当缺失了应用状态，就需要重新登录。")]),a._v(" [中核三维看板和后台]")]),a._v(" "),s("el-image",{attrs:{src:"/beifen/761.jpg"}}),a._v(" "),s("el-image",{attrs:{src:"/beifen/766.jpg"}}),a._v(" "),s("p",[a._v("2."),s("code",[a._v("前端微服务化")]),a._v("，在不同的框架之上设计通信和加载机制，已在一个页面内加载对应的应用。每个前端应用都是完全独立自主运行，最后通过模块化的方式组合出完整的前端应用。采用这种方式意味着从一个页面上同时存在两个及以上的前端应用在运行，而路由分发方案则是，一个页面只有唯一一个应用。[qiankun]")]),a._v(" "),s("p",[a._v("如：single-spa等")]),a._v(" "),s("el-image",{attrs:{src:"/beifen/762.jpg"}}),a._v(" "),s("p",[a._v("3."),s("code",[a._v("微应用")]),a._v("，通过软件工程的方式，在部署构建环境中，把多个独立应用组合成单体应用.微应用话与微服务化架构类似，他们在开发时都是独立应用，在构建时又可以按照需求单独加载。原理上，做的只是从多个项目中复制出代码，然后合并到一个项目中。[angluar]")]),a._v(" "),s("el-image",{attrs:{src:"/beifen/763.jpg"}}),a._v(" "),s("p",[a._v("如下图，一个angular应用，除了主的app模块，还包含dashboard，settings，reports模块，在微应用化中，上述应用便是最后构建过程中的应用，在构建之前是以独立app存在的。而主的app模块下的功能，则可以变成主工程。这时，一共有四个代码仓库：")]),a._v(" "),s("p",[a._v("主代码仓库，空白框架式代码，可以独立构建，构建完成则成为另外三个应用的完整工程。")]),a._v(" "),s("p",[a._v("dashboard应用，在构建时复制对应的模块，目录的到吗到主工程。settings应用，同上。reports应用，同上。\n"),s("el-image",{attrs:{src:"/beifen/767.jpg"}})],1),a._v(" "),s("p",[a._v("4."),s("code",[a._v("微件化")]),a._v("，开发一个新的构建系统，将部分业务功能构建一个独立的chunk代码，使用时只需要远程加载即可[中核app]")]),a._v(" "),s("el-image",{attrs:{src:"/beifen/764.jpg"}}),a._v(" "),s("p",[a._v("5."),s("code",[a._v("前端容器化")]),a._v("，将iframe作为容器容纳其他应用[iframe]")]),a._v(" "),s("p",[a._v("6."),s("code",[a._v("应用组件化")]),a._v("，借助web components技术，来构建跨框架的前端应用")]),a._v(" "),s("el-image",{attrs:{src:"/beifen/765.jpg"}})],1),a._v(" "),s("h3",{attrs:{id:"js-模板-虚拟dom-原生createelement在更新页面性能对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js-模板-虚拟dom-原生createelement在更新页面性能对比"}},[a._v("#")]),a._v(" [js]模板+虚拟dom+原生createElement在更新页面性能对比")]),a._v(" "),s("Open",[s("el-image",{attrs:{src:"/beifen/772.png"}}),a._v(" "),s("p",[a._v("在创建阶段，innerHTML和虚拟dom相比，基本性能一致，甚至是略微还有优势")]),a._v(" "),s("p",[a._v("在更新阶段，则考虑到内容的多少，操作的内容越多，innerHTML的性能消耗越大")])],1),a._v(" "),s("h3",{attrs:{id:"js-1-2-3-map-parseint"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js-1-2-3-map-parseint"}},[a._v("#")]),a._v(" [js][1,2,3].map(parseInt)")]),a._v(" "),s("Open",[s("p",[a._v("arr.map(callback: (value: T, index: number, array: T[]) => U, thisArg?:any);")]),a._v(" "),s("p",[a._v("而 parseInt 则是用来解析字符串的，使字符串成为指定基数的整数。接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。\nparseInt(string, radix)")]),a._v(" "),s("p",[a._v("parseInt('1', 0) //radix 为 0 时，且 string 参数不以“0x”和“0”开头时，\n按照 10 为基数处理。这个时候返回 1parseInt('2', 1) //基数为 1（1 进制）\n表示的数中，最大值小于 2，所以无法解析，返回 NaNparseInt('3', 2) //基数\n为 2（2 进制）表示的数中，最大值小于 3，所以无法解析，返回 NaN")])])],1)}),[],!1,null,null,null);s.default=r.exports}}]);